#version 430
out vec4 color;

in vec3 pos;
in vec2 uv;
in vec3 nrml;
in vec4 shadowPos;

uniform sampler2D shadowMap;
uniform sampler2D diffuseTexture;
uniform vec3 lightDir;
uniform vec3 viewPos;
uniform vec4 baseCol;
uniform mat3 srtMatrix;

const float shadowBias = 0.0026;


float fetchShadow(vec4 pos){

	vec3 projCoords = pos.xyz / pos.w;
	projCoords = projCoords * 0.5 + 0.5;
	float sampledDepth = texture(shadowMap, projCoords.xy).r;
	float currentDepth = projCoords.z;
	
	return step(currentDepth - shadowBias, sampledDepth);

}


void main(){

    vec2 transformedUV = vec2(srtMatrix * vec3(uv, 1.0));
    vec4 fullTexColor = texture(diffuseTexture, transformedUV);
    vec3 texcolor = fullTexColor.rgb;
	
    // ambient
    vec3 ambient = 0.05 * texcolor;
	
    // diffuse
    vec3 normal = normalize(nrml);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * texcolor;
	
    // specular
    vec3 viewDir = normalize(viewPos - pos);
    float spec = 0.0;
	
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
    
    vec3 specular = vec3(0.3) * spec; // assuming bright white light color
	
	float shadow = fetchShadow(shadowPos);
	vec3 blinnPhongColor = ambient + shadow * (diffuse + specular);
	
	/*
		float distance = length(lightPos - pos);

		// attenuation

		float a = 1.0;
		float b = 0.09;
		float c = 0.0032;
		float x = distance;

		// a / (1 + b * x + c * x ^ 2)

		float attenuation = a / (1.0 + b * x + c * x * x);
		blinnPhongColor *= attenuation;
	*/
	
    color = vec4(blinnPhongColor, fullTexColor.a);
    color *= baseCol;

}